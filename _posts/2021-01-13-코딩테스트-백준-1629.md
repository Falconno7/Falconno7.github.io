---
title: "BOJ-1629 곱셈"
excerpt: "재귀적 풀이법과 함께 mod의 개념에 대해 설명합니다."
categories:
    - 코딩테스트
tags:
    -BOJ
    -재귀
    -mod
    -지수법칙
    -느낀점
toc: true
toc_sticky: true
use_math: true
---

## 1. 문제 관찰
* 문제에서 주어지는 시간제한은 0.5초이므로 최대한 단시간에 풀어낼 수 있는 코드를 작성해야 합니다.<br/>
<br/>
* 자연수 A를 B번 곱한 수 = $A^B$ 이며 이를 C로 나눈 나머지는 $A^B mod C$가 됩니다.
<br/>
* A,B,C가 모두 $<= 2,147,483,647$ 까지의 숫자인 것을 감안했을 때, C++, JAVA로 푸시는 분들은 BigInteger를 사용하는 것이 안전하다고 생각합니다.
<br/>
* 또한, 시간제한과 값의 크기를 고려했을 때, 단순히 $A^B mod C$ 형태로 계산하는 코드를 작성해서는 풀 수가 없습니다.
<br/>

## 2. 문제에 앞서서 필요한 개념 설명.
* **mod**의 개념에 대해.<br/>
    * mod가 필요한 이유를 알기 위해서 다음 예제를 풀어봐주시기 바랍니다.<br/>
    <예제><br/>
    1486 * 2945 * 34 의 1의 자리 수는?<br/>
    <br/>
    아마도 본능적으로 각 숫자의 1의 자리수만 곱해서 문제를 푸셨을 것입니다.<br/>
    풀이과정을 컴퓨팅적 사고로 따라해보면, <br/>
    1. $6 * 5 = 30$<br/>
    2. 30이 10보다 크기 때문에 10으로 나눠서 남은 수만 골라냄. -> 30 mod 10 = 0<br/>
    3. $0 * 4 = 0$ 이므로 1의 자리 수는 0이 됩니다.<br/>

    * 이 과정에서 알 수 있는 점.<br/>
    1. 1의 자리 수 만 계산하기 때문에 숫자가 아무리 커도 계산량은 일정함.<br/>

* **mod** 개념 응용.<br/>
    * 위 예제의 형태를 수식으로 나타내자면,<br/>
    1486 * 2945 * 34 mod 10$ 즉, <br/> 
    $A * B * C mod D$의 형태로 나타낼 수 있습니다.<br/>
    여기서 D의 부분이 바뀌게 되면, 말로는 다음처럼 됩니다.<br/>
    D = 11의 경우.<br/>
    11진수에서 1486 * 2945 * 34의 1의 자리는 ?<br/>

    * 여기까지 보셨다면 눈치를 채셨을 수도 있으실 겁니다.<br/>
    $A * B * C mod D$ 에서 B와 C가 A라고 생각하면,<br/>
    $A * A * A mod D$가 되고, 지수처리까지 하게 되면<br/>
    $A ^ 3 mod D$ 가 됨으로써 BOJ-1629 곱셈문제에서 물어보는 것과 같은 식이 나오게 됩니다.<br/>

    * 그렇다면, 우리는 예제를 통해 배운 것처럼 A의 1의 자리수를 B번 지수곱 해주면서 사이에 mod를 끼워넣어 나머지 수만 챙겨주면 된다는 것을 알게 됩니다. <br/>
    이제 예제를 말로 풀어서 설명해 보겠습니다.<br/>
    <예제><br/>
    $8^7 mod 12$를 푼다고 생각해보자.<br/>
    1. $8^1 mod 12 = 7$ 즉 12진수에서 7의 1의 자리 수는 8이다.<br/>
    2. $8^2 mod 12 = 1$ 즉 12진수에서 8 * 8의 1의 자리 수는 4이다. 이는 직전의 결과의 8에 8을 곱한 후, 12로 나눠서 나온 나머지와 같다.<br/>
    3. $8^3 mod 12 = 1$ 즉 12진수에서 8 * 8 * 8 의 1의 자리 수는 8이다. 이는 직전의 결과의 4에 8을 곱한 후, 12로 나눠서 나온 나머지와 같다.<br/>


## 3. 예제를 통한 통찰(재귀함수 구현)

* 위의 예제를 통해 재귀함수를 구현하는 프로세스를 설명하겠습니다.<br/>
    <예제><br/>
    $8^7 mod 12$를 푼다고 생각해보자.<br/>
    1. $8^1 mod 12 = 7$ 즉 12진수에서 7의 1의 자리 수는 8이다.<br/>
    2. $8^2 mod 12 = 1$ 즉 12진수에서 8 * 8의 1의 자리 수는 4이다. 이는 직전의 결과의 8에 8을 곱한 후, 12로 나눠서 나온 나머지와 같다.<br/>
    3. $8^3 mod 12 = 1$ 즉 12진수에서 8 * 8 * 8 의 1의 자리 수는 8이다. 이는 직전의 결과의 4에 8을 곱한 후, 12로 나눠서 나온 나머지와 같다.<br/>

1. **base condition**<br/>
* n == b일 때 재귀함수 호출을 멈추고, 결괏값을 출력합니다. *예제에서는 b = 7*<br/>
```python
if n == b:
    print((a * a) % c)
``` 
<br/>
2. n이 1 < n < b 일 때 재귀함수의 내부를 구현해봅니다. <br/>
n == 4 라고 가정하면,<br/>
$8^4 mod 12 = (8^3mod12) mod 12$가 됩니다.<br/>
코드로 표현하면,<br/>
```python
def multiplication(a, n, b, c, d): #d는 직전 재귀의 계산값이 됩니다. 재귀함수 도입부에서는 d = a로 시작합니다.
    if n == b:
        print((d * a) % c)
    else:
        multiplication(a,n+1 ,b, c, (d * a)%c)
```
<br/>
* 지금까지 설명한 코드로는 RecursionError가 뜰 가능성이 큽니다. <br/>
이유는 100000 ** 100000 같은 큰 수가 들어왔을 때, 재귀의 깊이가 너무 깊어지기 때문입니다.<br/> 이 문제를 해결하기 위해 개량형 코드를 짤 필요가 있습니다.<br/>

## 4. 개량형 코드.
* 지수법칙의 $3 ^ 2 * 3 ^2$ = 3 <sup>(2+2)</sup>를 응용하는 방법입니다.<br/>
$8^4 mod 12 =$ 를 예를 들면 <br/>
$8^4 = 8^2 * 8^2$가 성립하게 되는 것을 알 수 있습니다.<br/>
양 변에 mod 12를 붙이면<br/>
$8^4 mod 12 = (8^2*8 ^2)mod 12$ 또한 성립합니다.<br/>
또한,<br/>
$8^4 mod 12 = 8^2 mod12 * 8 ^2mod 12$도 성립하는 것을 알 수가 있습니다.<br/>

* 위 과정을 재귀적으로 돌게 되면, 다음과 같은 프로세스가 완성됩니다.<br/>
a = 8, b = 7, c = 12 일 때,<br/>
**BaseCondition**은 b가 1이 됐을 때 그만 두는 것이며,<br/>
b가 n일 때는 b가 b//2 일 때의 값, 즉 8<sup>b//2</sup> mod 12 의 값을 2번 곱해준 후, 출력합니다.<br/>
단, b가 홀 수 일 때는 a를 1번 더 곱해서 출력해줘야 합니다.<br/>

* 위 프로세스를 코드로 나타내게 되면, 다음과 같은 코드가 완성됩니다.<br/>
```python
def multiplication(a,b,c):
    if b == 1:
        return a % c
    else :
        val = multiplication(a,b//2,c)
        if (b%2) == 0:
            return (val * val) % c
        else:
            return (val * a) % c
```

## 5. 참고 및 출처<br/>

* 본 풀이는 [바킹독](https://baaaaaaaaaaaaaaaaaaaaaaarkingdog.tistory.com/943?category=773649)님의 강의를 참고하여 작성하였습니다.<br/>
<br/>
---

## 느낀 점
* 이 문제는 재귀 이전에 수학의 통찰력이 필요로 하는 문제였습니다.<br/>

* 이 문제를 풀면서, 재귀가 어느정도 틀이 잡히는 것 같습니다.<br/>

* 이 문제를 포스팅 하면서 따로 재귀를 연습하기 위해, 모든 경우의 수를 list에 담아내는 재귀함수를 구현해 봤습니다.<br/>